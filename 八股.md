[TOC]

flutter ,compose

**对属性动画了解吗 帧动画，view动画，属性动画** 

属性动画 : valueanimator ， objectanimator ，view.animator()

View类有一个animate()方法，返回的是一个ViewPropertyAnimator对象



优化方式有多种，为什么会选择这种

okhttp 缓存

**可滑动列表下用户快速滑动导致白屏如何处理？** 

增大缓存提高视图复用

用户在快速滑动时，可能视图回收和复用的效率不够，导致新项未能及时创建或绑定数据，从而出现空白。这时候可能需要调整缓存的大小，比如增大RecyclerView的setItemViewCacheSize，这样可以让更多的视图保留在缓存中，减少滑动时的创建和绑定时间。

简化布局结构，减少布局嵌套

每个项的布局过于复杂，包含大量嵌套或复杂的视图层次，会导致测量和布局时间过长。优化布局，使用ConstraintLayout减少嵌套，或者简化布局结构，可以加快渲染速度

数据加载方面是否有耗时操作在主线程执行，切换到子线程中执行

**view绘制流程**

viewrootimple 执行perform Traversals() ,performmeasure(根据父view创建自身的measurespec，先递归测量保存子view宽高，最后再根据子view保存自身的宽高),performlayout,performdraw（绘制背景，绘制内容，处理子view，invalidate（）触发重绘，Animation实现动画）;

如果想扩大一个View的响应范围而且不加padding，怎么做？重写ontouchevent（），交给父view处理，父view拦截事件主动分发

用户会上下滑，滑动列表会卡顿，这种怎么解决？ 减少UI过度绘制，使用recyclerview对象池复用对象

项目基本，redux架构，rxjava操作符

如何优化布局结构

学习中印象深刻 recyclerview，okhttp
设计模式 : 单例模式，责任链模式，工厂模式，建造者模式，代理模式，观察者模式

**了解的加密机制** 

**加密算法**

**引用类型：**

> 引用类型主要是一些**类、接口、数组**
> 引用类型变量中存储的是**地址**，对应的**地址存储数据**

**拷打15分钟项目，说说你觉得难的点，怎么解决的**

**看你简历做算法很有优势为什么想来做客户端**

**面试官先介绍部门情况，然后让我自我介绍（面试官觉得自我介绍有点短）**

**学习过程中印象深刻的东西** 

HTTPDNS 为什么能加快解析的

大量数据插入和查询如何保证快速

优化速率大概是多少，apk包优化，查看前后优化速率

glide是如何减少内存占用的，你们做了什么优化呢，后续怎么处理的呢 （压缩尺寸，格式优化，bitmap内存复用，应用退出后采用Glide.clearmemory）

之所以使用内存缓存的原因是：防止应用重复将图片读入到内存，造成内存资源浪费。
之所以使用磁盘缓存的原因是：防止应用重复的从网络或者其他地方下载和读取数据。

自定义view实现动画效果，通过Animate实现

EventBus是什么设计模式

view绘制，触摸事件分发



自我面试，过往经历，

面试官你好，我叫xxx，目前就读于长沙理工大学计算机科学与技术专业

在大一和大二的时候加入学校ACM实验室参加算法竞赛，取得了不错的成绩，之后开始学习Android方面的知识，在这方面主要实现了长理星球这个项目，提供在校学生的一些日常需求，比如课表查询，成绩查询，我的职责主要是负责项目移动端开发，包括基础框架的实现和后续的优化

# Android八股

**非常高频！！！**

四大组件：能说是哪四个就行，基本只问activity，另外三个几乎不问

activity的生命周期 7次

activity的启动模式 4次

安卓线程间通信方式（handler）6次

安卓进程间通信方式（binder）5次

view的绘制流程 4次

触摸事件的传递 4次

*****************

线程异常处理: runnable接口异常捕捉，callable接口异常抛出，通过futuretask捕捉

线程池异常捕捉：一种是execute()方法提交Runnable无返回值的任务，另一种是submit()方法提交Callable有返回值的任务。而使用submit()方法提交任务是有坑的，如果提交之后没有使用get方法获取返回值，异常信息就丢了。Runnable接口任务无法在主线程中捕获，需要在子线程中捕获异常

线程间通信方法： handler ， 协程， rxjava，LiveData

HTTP适用于不需要保护用户隐私和[数据安全](https://cloud.baidu.com/solution/security/datacirculation.html)的场景，如公共信息网站、博客等；HTTPS则适用于需要保护用户数据的场景，如在线支付、用户登录、个人信息提交等

app间传输数据的方式：intent ，文件共享 ，通过broadcast 传输数据， contentprovider ,service :应用间的服务连接，如果 App B 需要为 App A 提供服务功能，可以让 App A 绑定到 App B 的服务

LiveData作用： 

- 屏幕旋转导致 Activity 销毁重建。
- `ViewModel` 保持存活，其内部的 `LiveData` 数据不变
- 数据变化自动通知处于活跃状态的观察者更新UI
- 自动感知观察者的生命周期（如 Activity 的 `onDestroy`），在界面销毁时解除订阅

activityA启动后打开activityB，两个activity的状态经历了哪些周期？

可以在子线程里面刷新UI吗？如果我非要在子线程里刷新了UI呢？会怎么样？会抛出什么异常？

ANR是什么？ANR产生的根本原因是什么？多久会出现这个异常？所有的情况都是 5s 吗？Service里面也是5s吗？

application的oncreate和activity的oncreate有什么区别?

Ibinder了解吗？

一个点击事件点击结束后是怎么被销毁的？

looper的睡眠机制对应linux的哪个操作？

looper最多能开几个线程？

handler的一个postDelay()方法知道吗？

如果创建了两个handler，如何知道哪个消息对应哪个handler？

上下滑动事件和左右滑动事件的冲突如何处理？

recyclerView了解吗？它是如何复用视图的？

activity和fragment之间是如何进行通信的？

常见的内存泄露?	

1单例造成的内存泄漏 2非静态内部类和匿名内部类造成的内存泄漏3Handler造成的内存泄漏4资源未关闭造成的内存泄漏5子线程造成的内存泄漏

1.说一下HashMap怎么实现的，扩容机制
2.HashMap是线程安全的吗？为什么？线程不安全会导致哪些后果？
3.如何解决HashMap线程不安全的问题？

1.Http协议是可靠的吗？
2.TCP为什么是可靠的？
3.TCP三次握手，四次挥手

3.OKhttp如何使用？拦截器是怎么用的？说一下OKhttp内部的五大拦截器
4.OKhttp缓存策略？
5.文件下载和普通的接口请求有什么不同？

Java基础数据类型
Java集合中常用的类
hashmap和hashlist的原理

一面

1. okhttp相关（优点、拦截器）
2. 自定义view
3. 触摸事件
4. activity生命周期
5. 多线程通信
6. 协程调度器
7. 算法：字符串求回文子串数目


二面

1. 值传递和引用传递
2. 自动装拆箱会遇到什么问题
3. 了解的加密机制
4. 什么是非对称加密，什么是对称加密
5. handler
6. Android布局
7. hashmap扩容和解决冲突
8. 算法题：有序数组去重

在Activity和Service中创建Thread的区别

java中单列类是拿什么实现 （singleton）

kotlin高阶函数

如何在singletop模式中启动activity并传输数据 （在onNewintent（）方法中读取，在onstart（）方法中读取数据不一样）

retorfit如何避免重复添加header头（使用okhttp添加自定义拦截器）

recyclerview如何设置头布局和尾布局

10分多钟八股，线程池、参数配置、默认线程池、Atomic类、synchronized、volatile、JVM结构、GC、可达性分析、GC Root、finalize，进程线程、三次握手四次挥手、TCPUDP，吟诵即可，问了个okhttp不会

拷打15分钟项目，说说你觉得难的点，怎么解决的

两道算法，一个经典2*N多米诺骨牌，一个力扣240，五分钟敲完

java线程池
java线程同步的方式
讲讲死锁
什么是悲观锁和乐观锁
线程和进程的区别

根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

线程运行于进程

线程之间切换的开销小，进程较大

进程内存占用更大，线程内存占用小

http和https

TCP是osi哪一层的   

​    tcp和udp区别   

​    微信视频是用了tcp还是udp   

​    udp的优点   

​    http基于tcp还是udp   

​    http3有了解吗   

​    http3是基于tcp还是udp   

​    为什么很多用https而不用http   

​    加密算法有了解吗   

​    什么是对称加密和非对称加密   

​    https的加密是对称的还是非对称的   

​    为什么https没有一直用非对称加密（非对称加密的缺点）

Android四大组件作用及应用场景  

   activity四个启动模式？  

   singleTask如何实现栈内复用（clearTop特性）  

   singleTask会调用activity中的哪个方法？（onNewIntent）  

   调用onNewIntent之后会走哪些生命周期？  

   service在项目中怎么使用？  

   两种service有什么区别？  

   IntentService和普通的service有什么区别？  

   service如何通信？  

   子线程能否直接更新UI？  

   怎么在子线程中更新UI？  

   Handler机制工作流程？  

   为什么可以在Handler中更新UI？  

   RecycleView如何实现多类型的显示？具体调用哪些方法？  

   如何做的性能优化？  

   如果有一张巨大的图如何加载到尺寸很小的imageview？  

   Glide加载流程？  

   Looper如何将消息队列中的消息分发给Handler？可能会把同一个消息给多个Handler吗？  

   反问：业务，招聘时更看重基础能力还是项目契合程度？（因为面试没问任何八股，好多Android挖的还比较深，面试官说因为部门实在太忙，没有时间带，所以更看重业务能力，最好来了能直接上手业务）

intent传输数据有大小限制吗，图片能通过intent传输吗

# Java八股

**多态实现形式: 类继承父类，类实现接口** 

Java中==和equals的区别 equals不能用于基本变量

 == 在基本数据类型：值内容, 引用类型时：地址
equals 重写：值内容 ， equals不重写：地址

**自动装拆箱会遇到什么问题**,我们只需要知道，当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象。有些场景会进行自动拆装箱，同时也说过，由于自动拆箱，如果包装类对象为 null ，那么自动拆箱时就有可能抛出空指针异常

**Java中的反射机制，可以用于实现什么东西？一般怎么用** 

动态实例化对象，序列化和反序列化，绕过访问限制，动态代理

**用过注解吗？注解，一般是在什么时候去处理的，在哪个阶段？（这个有点深）**

**注解的作用**： 

- 作为特定标记，用于告诉编译器一些信息
- 编译时动态处理，如动态生成代码
- 运行时动态处理，作为额外信息的载体，如获取注解信息

注解分类: 元注解（@Retention，@Target（允许自定义注解标注在哪些Java元素上），@Inherited），标准注解， 自定义注解

 从编写Java代码到运行主要周期为`源文件`→ `Class文件` → `运行时数据`，@Retention则标注了自定义注解的信息要保留到哪个阶段，分别对应的value取值为`SOURCE` →`CLASS`→`RUNTIME` 

注解是一个接口对象，

**arrayList** 初始化 10 ，扩容 1.5 ，add() , get() , set(index,value),remove(),size(),

list转数组不受影响，数组转list受影响

**linkedList**

**hashmap** 初始化 16 ，扩容 2 , put(),get(),remove(),数组长度大于64并且链表长度大于8才会将链表转换为红黑树

默认加载因子 0.75，扩容遍历旧数组，重新计算索引下标 判断 hash & oldCap == 0 ? 旧位置: 旧位置 + oldCap 

计算索引 :先将hashcode右移16位再计算，让哈希分布更加均匀， (n - 1) & hash 代替取模效率更高



final关键字:修饰类不可继承，修饰方法不可被重写，可以被重载，修饰基本变量不可被修改，修饰对象首指针不可变

String如何做到不可被修改：final关键字修饰value，并且将其私有未提供方法修改，final修饰String类，避免子类修改

static是不允许用来修饰局部变量

静态方法不能调用非静态成员

静态代码块

静态初始化块可以置于类中的任何地方，类中可以有多个静态初始化块。
在类初次被加载时，会按照静态初始化块的顺序来执行每个块，并且只会执行一次。

静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）

![image-20250306215351166](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250306215351166.png)

线程和进程的区别：进程是操作系统资源调度的基本单位，线程是任务分配和执行的基本单位

进程是正在运行程序的实例，进程中包含线程

不用进程使用不同的内存空间，当前进程下的所有线程可以共享内存空间

线程更轻量，线程间切换相对于进程间切换成本更低

并行和并发：多个CPU同时运行多个线程：多个线程轮流使用CPU

线程创建方式:继承Thread类，实现runnable接口，实现callable接口，线程池创建

runnable和callable有什么区别：返回值，使用FutureTask获取结果

callable允许向上抛出异常，runnable只能内部消化

线程状态:new , runnable ，blocked （阻塞）waiting （waiting）timed_waiting（sleep），terminated

wait和sleep不同:所属对象不同，wait属于Object类，sleep属于Thread类

wait必须配合synchronizd使用，waiting时会释放锁，sleep不会

wait可以通过notify或notifyall唤醒

停止线程：interrupt（打断阻塞的进程会抛出异常（sleep，wait，join）），volatile关键字标志位，stop强行终止（废弃）

synchronizd底层：monitor ： owner(拥有锁的线程) ，entryList （阻塞线程等待线程未排队，线程竞争机制，所有在EntryList中的线程会竞争获取锁，而不是按顺序唤醒），waitset

### **为什么采用非公平策略？**

避免线程频繁切换带来的上下文开销。新到达的线程可能更快执行，提升整体吞吐量

synchronized如何绑定monitor？ markword中保存了monitor地址

**monitor重量级锁，成本高性能低** 

**轻量级锁，偏向锁** 

JMM：分为工作内存和主内存，线程跟线程相互隔离，交互需要通过主内存

CAS:比较交换，不断自旋锁，基于乐观锁思想

volatile：防止编译器优化，让线程对象共享变量修改对另一个线程可见 ，变量更新立即刷新到主存，读取时会强制从主存中读取值（忽略缓存）

AQS：一种锁，多种实现类

state，使用cas保证原子性

FIFO链表实现双向队列，头指针和尾指针，公平锁和非公平锁都可以实现

Reentrantlock : CAS + AQS实现，exclusiveOwnerThread 当前持有锁的线程

synchronized和Reentrantlock区别：synchronized 自动释放，锁竞争激烈Reentrantlock有多种策略，公平锁与非公平锁的选择，可中断的锁获取和超时机制，自旋优化

死锁条件：多个线程进入资源相互等待

Concurrenthashmap：cas + synchronized，synchronized只锁首节点,CAS添加首节点

控制方法线程执行数量:semaphore.acquire semaphore.release

ThreadLocal:实现资源对象线程隔离， 让每个线程使用各自的资源对象，避免争用引发的线程安全问题

ThreadLocalMap：存储资源对象

内存泄漏：ThreadLocalMap中key为弱引用，value为强引用，使用remove

线程池参数：核心进程数，最大进程数，临时线程存活时间，时间单位，阻塞队列，线程工厂，拒绝策略

线程池中常见的阻塞队列：arrayblockingqueue （数组）， linkedblockingqueue （单链表），delayworkqueue（优先队列，执行时间最靠前的） ，synchronousqueue （不存储元素的队列）

线程池种类 : fixthreadpool (核心线程数 == 最大线程数，阻塞队列存储元素可达最大值)

​		singlethreadpool （阻塞队列存储元素可达最大值） 

​		cachedthradpool（核心线程数为0 ，临时线程可达最大值，不存储元素的阻塞队列，临时线程存活时间为60秒）

​		schedulethreadpool （延迟和周期执行的任务，临时线程存活时间为0 ）

![image-20250306220205946](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250306220205946.png)

# JVM

JVM内存模型: 虚拟机栈，本地方法栈，方法区，堆区，程序计数器

gc太频繁了会导致性能问题，不希望他频繁回收，怎么解决 ? 减少对象分配（延迟初始化），对象池复用，

程序计数器：线程私有，记录程序运行行号

java堆：线程共享，存储数组和java对象，分为年轻代和老年代，jdk1.7 和 jdk1.8永久区 

方法区：线程共享区域，虚拟机启动时创建，关闭时释放，存放类信息，常量池 ，静态变量

常量池:可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名方法名、参数类型、字面量等信息。当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

直接内存：不属于JVM管理，读写性能高，回收成本高 

类加载器主要负责将类的字节码加载到JVM中，转换成Class对象

类加载器：启动类加载器，扩展类加载器，应用类加载器，自定义类加载器，双亲委派模型

类加载过程：加载，验证（合规性验证，引用验证），准备（类变量赋值默认值，final修饰基本变量赋值，引用变量不赋值），解析（符号引用转化为直接引用），初始化，使用，卸载

加载:查找和导入class文件
验证:保证加载类的准确性
准备:为类变量分配内存并设置类变量初始值
解析:把类中的符号引用转换为直接引用

初始化:对类的静态变量，静态代码块执行初始化操作
使用:JVM 开始从入口方法开始执行用户的程序代码

卸载:当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象:

双亲委派模型: 避免重复加载，保证加载安全性

垃圾回收：计数引用算法， 可达性分析算法

GCRoot:栈中变量，方法区中常量，方法区中静态变量，本地方法栈中变量native方法变量

回收算法：标记清除算法，复制算法，标记整理算法

垃圾回收器：串行垃圾回收器，并行垃圾回收器，CMS垃圾回收器（主要作用在老年代),G1垃圾回收器（作用在新生代和老年代）

串行垃圾回收器: serial (新生代，复制算法),serialold（老年代，标记整理算法）,

并行垃圾回收器： parallel new (新生代，复制算法)，parallel old（标记整理算法）

CMS垃圾回收器：初始标记（线程阻塞) , 并发标记，重新标记 ，并发清理（其它线程可继续运行）主要对老年代的垃圾回收，采用标记清除算法

G1垃圾回收器：划分成多个区域，每个区域都可以充当eden，survivor，old，humongous，采用复制算法 

新生代垃圾回收，并发标记线程不会阻塞，重新标记线程阻塞（老年代占用超45%），混合收集（根据暂停时间目标回收价值高的对象）

内存大对象分配连续humongous区

g1垃圾回收器内存为什么分为一块一块的？ 分区允许G1以Region为单位进行回收，优先处理垃圾最多的区域（Garbage-First），这样每次回收可以更高效，且停顿时间可控

强引用，弱引用，软引用，虚引用（配合引用队列使用，对象被回收时，将虚引用入队，有reference handler释放内存）

**volatile和synchronized的区别** 
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

# HTTP

如果用UDP做传输，无可避免的有数据丢包，怎么办？接收方检测丢包后，发送 NACK（否定确认）请求重传特定丢失的包。数据包中增加冗余信息，接收方可通过冗余数据恢复丢失的部分包，**无需重传**

cpu在线程调度的时候，是什么流程 ? 保存当前线程上下文，cpu调度选择线程，切换线程执行线程

问了DNS协议、以及DNS缓存：浏览器缓存、操作系统缓存、本地DNS服务器缓存，还有路由器缓存

Tcp建立的数量是否有限，有什么限制？从输入网址下回车那一刻，到屏幕上显示内容，中间经过哪些过程？

Get和POST请求的方法有什么区别？项目里都用了什么请求方法？（get,post,put,delete）Post和Get的方法哪个比较安全？

为什么需要 TCP 协议？可靠传输，流量控制，拥塞控制， TCP ⼯作在哪⼀层？

IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。，需要使用TCP来可靠传输数据

什么是 TCP ？TCP 是**⾯向连接的、可靠的、基于字节流**的传输层通信协议

TCP和UDP区别 头部开销，传输效率

传输方式， 流量控制和拥塞控制

应用场景:tcp ,可靠交付HTTP / HTTPS，具体：支付场景 

udp : 广播通信，具体: 语音通话，视频通话，DNS

TCP连接前两次握手无法携带数据，第三次可以

TCP三次握手的原因 ：三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）。客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送RST 报⽂给服务端，表示中⽌这⼀次连接。

三次握⼿才可以同步双⽅的初始序列号

三次握⼿才可以避免资源浪费

为什么客户端和服务端的初始序列号 ISN 是不相同的？如果⼀个已经失效的连接被重⽤了，但是该旧连接的历史报⽂还残留在⽹络中，如果序列号相同，那么就⽆法分辨出该报⽂是不是历史报⽂

为什么需要 TIME_WAIT 状态？防⽌旧连接的数据包，保证连接正确关闭

# Kotlin

内联函数:调用时直接替换在被调用的位置，lambda表达式不会创建函数对象，**内联函数的「函数参数」 不允许作为参数传递给非内联的函数**

kotlin lambda表达式创建匿名内部类实现函数接口

高阶函数：T.run ，with(T) ， T.apply， T.also，T.let

启动协程需要三样东西，分别是 **上下文**、**启动模式**、**协程体** 

上下文包括：Job，coroutineName，coroutinedispatcher，coroutineExceptionHandler

协程作用域创建方式：runBlocking{}，GlobalScope.launch， CoroutineScope.launch

启动协程：launch ，async异步启动同步等待

协程异常: 异常传播方式（向上传播，捕捉异常），异常处理方式（trycatch，CoroutineExceptionHandler，superviorjob）

launch向上传播，async抛出异常

调度器：dispatcher.default,dispatcher.io,dispatcher.main，dispatcher.unconfined,继承CoroutineDispatcher 

suspend挂起函数：切换线程（不会自动切换），转换成带有continuation对象的函数（实现callback接口）

协程启动模式：default，lazy，atomic（立即调度，不可取消），undispatcher

# 操作系统

Linux 内核提供了不少进程间通信的机制：	

管道（Pipe）
消息队列（Message Queue）
共享内存（Shared Memory）
信号（Signal）
套接字（Socket）
信号量（Semaphore）
内存映射文件（Memory-Mapped Files）
进程间通信存在的问题：

性能开销：由于进程间内存隔离，数据必须通过内核缓冲区传递，导致频繁的数据复制和上下文切换，增加性能开销。
同步与互斥：多个进程同时操作共享资源时，必须确保数据一致性，防止竞态条件和冲突，这需要使用复杂的同步机制，如锁、信号量等。

什么是线程同步

多线程访问为什么会出现问题

进程调度方式: 抢占式和非抢占式

进程调度算法：先来先服务算法，短作业优先算法（平均等待时间，周转时间最少，长作业饿死），优先级调度算法（动静态分配优先级），高响应比优先调度算法（先来先服务和短作业优先），时间片轮转算法（过长过短），多级反馈队列调度算法

页面置换算法:最佳置换算法（以后最长时间未使用），先进先出算法，最近最久未使用算法

I/O模型

多进程间通信一般有哪些方式？管道通信（半双工），消息队列，共享内存（信号量维护，信号量实际上是一个计数器，主要是实现进程之间的同步和互斥，而不存储通信内容），信号，mmap，socket网络通信

信号量定义了两种操作，p操作和v操作，p操作为申请资源，会将数值减去M，表示这部分被他使用了，其他进程暂时不能用。v操作是归还资源操作，告知归还了资源可以用这部分

信号通信是进程通信中最简单的一种，但是他所能携带的信息有限，他只是通知其他进程一个信号，而不能发送具体的数据。在操作系统中，不同信号用不同的值表示，每个信号设置相应的函数，一旦进程发送某一个信号给另一个进程，另一进程将执行相应的函数进行处理。也就是说先把可能出现的异常等问题准备好，一旦信号产生就执行相应的逻辑即可。

CPU的内核态和用户态切换开销大

用户态：不能使用计算机系统资源，不能改变cpu状态

内核态：可以使用计算机所有资源

**每个进程的 `4G` 虚拟空间地址，高位 `1G` 都是一样的，即内核空间。只有剩余的 `3G` 才归进程自己使用，换句话说就是， 高位 `1G` 的内核空间是被所有进程共享的！**

# Glide

with

在Activity内新建一个无UI的Fragment，这个特殊的Fragment持有一个Lifecycle。通过Lifecycle在Fragment关键生命周期通知RequestManger进行相关的操作。

在生命周期onStart时继续加载，onStop时暂停加载，onDestory是停止加载任务和清除操作。

缓存 二级缓存 + Bitmap对象池 磁盘空间 result 和 resource

diskCacheStrategy 启动缓存， 缓存原始图片和转换后的图片，避免重复加载

尺寸优化决定宽高，图片格式优化决定每像素所占内存，主动设置（RBG565）

bitmappool内存复用优化

避免加载过大图片：

1. override 限制图片尺寸
2. thumbnail 加载缩略图
3. Transformations 压缩图片

取消未完成的任务 ，在ondestory中取消

glide默认复用bitmap，避免bitmap被频繁回收

placeholder 使用占位图和 error 错误图提升体验

![img](https://img2020.cnblogs.com/blog/798986/202007/798986-20200715210707581-394777567.png)

首先从ActivateResource获取，是个值为弱引用的Map

MemoryCache和DiskCache是LruCache

#### **Q1：Glide如何防止加载大图导致OOM？**

**标准答案+优化方案**：  

1. **默认方案**：

• 根据ImageView尺寸自动计算采样率 

• 采用BitmapPool复用内存  

#### **Q2：LruCache和DiskLruCache如何实现线程安全？**

**实现原理**：  

1. **LruCache**：• 使用LinkedHashMap+同步锁  

   • trimToSize()时计算权重  

2. **DiskLruCache**：• 通过Journal日志文件保证原子性  

   • 采用Double-check Locking优化读写锁  
   
   **5.Glide怎么做大图加载**
   对于图片加载还有种情况，就是单个图片非常巨大，并且还不允许压缩。比如显示：世界地图、清明上河图、微博长图等
   首先不压缩，按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中
   所以这种情况的优化思路一般是局部加载，通过BitmapRegionDecoder来实现
   这种情况下通常Glide只负责将图片下载下来,图片的加载由我们自定义的ImageView来实现

# Lifecycle

activity和fragment实现lifecycleOwner接口

自定义观察器继承defaultLifecycleObserve

通过无界面的fragment传递生命周期改变

# by lazy

ViewModel是因为内部需要依赖Activity的成员变量mApplication，而mApplication是在attach时给赋值的。

ViewBinding的初始化需要依赖Window的layoutInflater变量，而Window变量也是在attach时赋值的。

关键还是通过委托的思想将变量初始化委托给了通用类型Lazy类

大致过程就是将变量类型替换成了Lazy类型，然后通过Lazy类的getValue方法返回真实类型，`getValue`方法里通过判空来判断是否是首次访问。

fragment懒加载setUserVisibleHint

# Android布局优化

### 异步加载

AsyncLayoutinflate

x2c

### 优化布局层级及复杂度

1、使用ConstraintLayout,可以实现完全扁平化的布局，减少层级
2、RelativeLayout本身尽量不要嵌套使用，能用LinearLayout就用LinearLayout，因为RelativeLayout需要测量上下、左右两个方向，而LinearLayout只测量设置的方向
3、嵌套的LinearLayout中，尽量不要使用weight，因为weight会重新测量两次
4、推荐使用merge标签，可以减少一个层级
5、使用ViewStub延迟加载
6、多使用include提高复用率减少加载时间，减少xml解析

### 避免过度绘制

避免view.ondraw中执行耗时操作，创建过度局部变量

**1.去掉多余背景色,减少复杂shape的使用
2.避免层级叠加
3.自定义View使用clipRect屏蔽被遮盖View绘制**

# sharedPreference

存在的问题

1.最终写入XML文件实用的是IO操作，IO操作需要两次拷贝，效率是比较低的

2.实用XML格式进行存储，并且全部以字符串的形式进行保存，浪费存储空间。比如value="469068865"。需要占用17个字节，utf-8一个英文字符占用1个字节，则存储该值需要17个字节。

3.每次编辑时，都需要对文件进行全量的写入操作。因为每次都是对完整的数据Map进行写入操作，哪怕只修改了一个值。这样做无疑是极大的浪费。

4.SP虽然支持多进程访问，但是多进程的读取是相当不安全的，因为进程间内存不能共享，而SP的多进程是每个进程一个对象进行操作。所以我们安全的使用方式仍然是使用一个进程去读取，并提供ContentProvider的方式供其它进程访问或者增加文件锁的方式，这样做无疑增加了我们使用复杂度。

5.线程阻塞问题。上面我们看到，只有全部加载完xml中的内容后，getString的函数才能继续往下执行。所以线程会被阻塞。

# MMKV

实现高效的文件操作：使用binder，基于mmap，把用户内存的一部分空间和内核内存的一部分空间映射到同一块物理内存上

实现更精简的数据格式：二进制

实现更优的数据更新方式：在后面追加，内存超过限制删除重复元素

Crc效验码解决多线程同步，读取文件之前，会先去读取CRC校验码，如果校验码和预期一致，则进行读取。否则更新校验码并且重新读取整个文件。

**线程阻塞问题**：同一个线程中，其原因其实MMKV通过mmap读取值是一个接近于内存级别的操作，所以不会有过多的耗时，因此无需切换线程。

# handler相关

message使用链表结构，回收message对象采用头插法

如果sPool为null时，新建一个Message

如果sPool不为null时，从对象池中获取Message对象，每次均从表头查询，即sPool记录的表头消息

Threadlocal使每个线程都持有一个ThreadlocalMap对象，ThreadLocalMap是数组实现，用key值通过hash计算索引，当数组元素达到 2/ 3时会扩容，key为弱引用引发内存泄漏问题

HandlerThread线程，该线程默认提供了getLooper()方法，一般线程是没有Looper的。

Looper中创建MessagQueuequeue并且记录当前线程

我们无法直接去创建MessagQueue对象，所以MessageQueue是在同包下的Looper内部进行创建的，同步屏障（了解）

MessageQueue 采用单链表的数据结构来维护消息列表，MessageQueue只是负责消息的插入和读取，而单链表在插入和删除上拥有更高的效率，所以采用单链表的结构对消息的维护和管理更加高效。

**idlehandler**

IdleHandler 被定义在 MessageQueue 中，它是一个接口。

mIdleHandlers它的类型是一个 ArrayList

`queueIdle()` 方法。同时返回值为 true 表示是一个持久的 IdleHandler 会重复使用，返回 false 表示是一个一次性的 IdleHandler

**IdleHandler 有什么用？**

1. IdleHandler 是 Handler 提供的一种在消息队列空闲时，执行任务的时机；
2. 当 MessageQueue 当前没有立即需要处理的消息时，会执行 IdleHandler；

**Q：MessageQueue 提供了 add/remove IdleHandler 的方法，是否需要成对使用？**

1. 不是必须；
2. IdleHandler.queueIdle() 的返回值，可以移除加入 MessageQueue 的 IdleHandler；

**Q：当 mIdleHanders 一直不为空时，为什么不会进入死循环？**

1. 只有在 pendingIdleHandlerCount 为 -1 时，才会尝试执行 mIdleHander；
2. pendingIdlehanderCount 在 next() 中初始时为 -1，执行一遍后被置为 0，所以不会重复执行；

**Q：是否可以将一些不重要的启动服务，搬移到 IdleHandler 中去处理？**

1. 不建议；
2. IdleHandler 的处理时机不可控，如果 MessageQueue 一直有待处理的消息，那么 IdleHander 的执行时机会很靠后；

**Q：IdleHandler 的 queueIdle() 运行在那个线程？**

1. 陷进问题，queueIdle() 运行的线程，只和当前 MessageQueue 的 Looper 所在的线程有关；
2. 子线程一样可以构造 Looper，并添加 IdleHandler；

IdleHandler 是 Handler 提供的一种在消息队列空闲时，执行任务的时机。但它执行的时机依赖消息队列的情况，那么如果 MessageQueue 一直有待执行的消息时，IdleHandler 就一直得不到执行，也就是它的执行时机是不可控的，不适合执行一些对时机要求比较高的任务

# Rxjava

观察者模式：Observe监听数据 Observable发射数据

操作符

创建操作符: create , just, fromarray

转换操作符：map（数据类型转换） ，flatmap (允许并发),contactmap（顺序发送）

过滤操作符：filter （过滤不满足条件的），distinct（去除重复项）,elementAt(发送指定位置的数据项)

组合操作符： merge ， contact

错误操作符：onErrorReturn , onErrorResumeNext ,retry

异步和线程控制：subscribeOn（） observeOn（）

流式编程：RxJava 支持链式调用，可以将多个操作符和观察者方法连接在一起

Flowable背压模式：BackpressureStrategy

onbackpressureBuffer 缓冲数据并等待消费者处理

onbackpressureDrop 丢弃过多的数据，只保留最新的数据

onbackpressureLatest保留最新的数据项，丢弃其余的数据

onbackpressureError 当数据流速度太快时，抛出异常以通知消费者处理背压问题

# 设计模式

单例模式

责任链模式 

观察者模式

工厂模式

建造者模式

代理模式

生产者消费者模式

# DNS

缺点:  

域名缓存问题：本地做一个缓存，直接返回缓存数据。可能会导致全局负载均衡失败，因为上次进行的缓存，不一定是这次离客户最近的地方，可能会绕远路。 

域名转发问题：如果是A运营商将解析的请求转发给B运营商，B去权威DNS服务器查询的话，权威服务器会认为你是B运营商的，就返回了B运营商的网站地址，结果每次都会跨越营商。

出口NAT问题：做了网络地址转化后，权威的DNS服务器，没法通过地址来判断客户到底是哪个运营商，极有可能误判运营商，导致跨运营商访问。

域名更新问题：本地DNS服务器是由不同地区，不同运营商独立部署的，对域名解析缓存的处理上，有区别，有的会偷懒忽略解析结果TTL的时间限制，导致服务器没有更新新的ip而是指向旧的ip。

解析延迟：DNS的查询过程需要递归遍历多个DNS服务器，才能获得最终结果。可能会带来一定的延时

### HTTPDNS

绕开了运营商的 Local DNS，有效防止了域名劫持，提高域名解析效率。另外，由于 DNS 服务器端获取的是真实客户端 IP 而非 Local DNS 的 IP，能够精确定位客户端地理位置、运营商信息，从而有效改进调度精确性。

1、LocalDNS劫持；

由于HttpDNS是通过 IP直接请求http获取服务器A记录地址，不存在向本地运营商询问Domain解析过程，所以从根本避免了劫持问题。

2、平均访问延迟下降：

由于是IP直接访问省掉了一次Domain解析过程，（即使系统有缓存速度也会稍快一些“毫秒级”）通过智能算法排序后找到最快节点进行访问。

3、用户连接失败率下降：

通过算法降低以往失败率过高的服务器排序，通过时间近期访问过的数据提高服务器排序，通过历史访问成功记录提高服务器排序。如果ip(a)访问错误，在下一次返回ip(b)或者ip(c) 排序后的记录。（LocalDNS很可能在一个ttl时间内（或多个ttl）都是返回记录)。

4、[域名解析](https://cloud.tencent.com/product/dns?from_column=20065&from=20065)异常及用户访问跨网的问题



### 大量数据如何保证快速插入

批量插入

关闭事务自动提交

避免在插入前创建索引，应插入后创建索引，边插入边维护索引，开销太大了

插入前关闭唯一性检查，之后再开启

### 大量查询数据优化

分页优化

针对分页查询偏移量大导致查询速度慢：

1. 使用适当索引，确保分页查询的排序字段（通常是时间戳或唯一标识符）上有适当的索引
2. 使用游标分页
3. 使用数据库缓存

针对查询数据量大的导致查询速度慢：优化查询语句，查询时，减少不需要的列，查询效率也可以得到明显提升





